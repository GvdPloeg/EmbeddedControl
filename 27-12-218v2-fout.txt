#include "evk1100.h"
#include <asf.h>

#include "print_funcs.h"
#include "pm.h"
#include "string.h"
#include <math.h>

#define PB0						GPIO_PUSH_BUTTON_0			// Push button 0 definition
#define PB1						GPIO_PUSH_BUTTON_1			// Push button 1 definition
#define PB2						GPIO_PUSH_BUTTON_2			// Push button 2 definition

#define RTC_ADDRESS				0x68						// RTC's TWI addressn
#define TWI_SPEED				FOSC32						// Speed of TWI communication
#define usart1					&AVR32_USART1				// Definition for USART1 communication

//static const gpio_map_t ADC_GPIO_MAP = {{ADC_POTENTIOMETER_PIN, ADC_POTENTIOMETER_FUNCTION}, {ADC_LIGHT_PIN, ADC_LIGHT_FUNCTION}, {ADC_TEMPERATURE_PIN, ADC_TEMPERATURE_FUNCTION}};
static const gpio_map_t POT_GPIO_MAP = {{AVR32_ADC_AD_1_PIN, AVR32_ADC_AD_1_FUNCTION}};
static const gpio_map_t USART1_GPIO_MAP = {{AVR32_USART1_RXD_0_0_PIN, AVR32_USART1_RXD_0_0_FUNCTION}, {AVR32_USART1_TXD_0_0_PIN, AVR32_USART1_TXD_0_0_FUNCTION}};
static const gpio_map_t DIP204_SPI_GPIO_MAP = {{DIP204_SPI_SCK_PIN,  DIP204_SPI_SCK_FUNCTION }, {DIP204_SPI_MISO_PIN, DIP204_SPI_MISO_FUNCTION}, {DIP204_SPI_MOSI_PIN, DIP204_SPI_MOSI_FUNCTION}, {DIP204_SPI_NPCS_PIN, DIP204_SPI_NPCS_FUNCTION}};
static const gpio_map_t TWI_GPIO_MAP = {{AVR32_TWI_SDA_0_0_PIN, AVR32_TWI_SDA_0_0_FUNCTION},{AVR32_TWI_SCL_0_0_PIN, AVR32_TWI_SCL_0_0_FUNCTION}};

static const usart_options_t USART_OPTIONS = {.baudrate = 115200,.charlength = 8,.paritytype = USART_NO_PARITY,.stopbits = USART_1_STOPBIT,.channelmode = USART_NORMAL_CHMODE};
static const spi_options_t SPI_OPTIONS = {.reg = DIP204_SPI_NPCS,.baudrate = 120000,.bits = 8,.spck_delay = 0,.trans_delay = 0,.stay_act = 1,.spi_mode = 0,.modfdis = 1};
//static const twi_options_t TWI_OPTIONS = {.pba_hz = FOSC0,.speed = TWI_SPEED,.chip = RTC_ADDRESS};

twi_options_t opt;
twi_package_t packet_received;
twi_package_t packet_send;

void var_delay_ms(int);
void Light_sensor(void);
void Temperature_sensor(void);

void Potmeter_control(void);
int  Potmeter_value(void);
char* itoa(int);
static void Joy_int_handler(void);
static void PB_int_handler(void);
char* set_time(void);
char* display_time(int);
char bcd_to_decimal(char);
char decimal_to_bcd(char);

void Write_RTC(void);
void Read_RTC(void);

int adc_value_light = 0;
int adc_value_temp  = 0;
signed short adc_value_pot   = -1;

void display_1(int, char*);
void display_2(int, char*);
void display_3(int, char*);
void display_4(int, char*);

int x = 1;
int y = 1;
int Button_cases = 3;
int time_uitgang[ 5 ] = {0, 0, 0, 0, 0};
int joy_button = 0;
int pot_value = 0;
int poort_number = 1;

uint8_t tbuffer[7];

void DH(int xx) { for(int ii = 0; xx > 0; ii++) { pow(10, ii); } }

void var_delay_ms(int mills) {
	delay_ms(mills * (FOSC0/AVR32_PM_RCOSC_FREQUENCY));
}
char bcd_to_decimal(char d){
	return ((d & 0x0F) + (((d & 0xF0) >> 4) * 10));
}
char decimal_to_bcd(char d){
	return (((d / 10) << 4) & 0xF0) | ((d % 10) & 0x0F);
}
char* itoa(int i){
	char const digit[] = "0123456789";
	char* p = 10;
	if(i<0){
		*p++ = '-';
		i *= -1;
	}
	int shifter = i;
	do{ //Move to where representation ends
		++p;
		shifter = shifter/10;
	}while(shifter);
	*p = '\0';
	do{ //Move back, inserting digits as u go
		*--p = digit[i%10];
		i = i/10;
	}while(i);
	return 10;
}

void INIT(){
	//CLOCK init
	pm_switch_to_osc0(&AVR32_PM, FOSC0, OSC0_STARTUP);
	pcl_switch_to_osc(PCL_OSC0, FOSC0, OSC0_STARTUP);
	sysclk_init();
	
	irq_initialize_vectors();
	cpu_irq_enable();
	
	//enable modules
	gpio_enable_module(DIP204_SPI_GPIO_MAP, 4);
	gpio_enable_module(POT_GPIO_MAP, 2);
	gpio_enable_module(USART1_GPIO_MAP, 2);
	gpio_enable_module(TWI_GPIO_MAP, 2);
	
	//SPI Display init
	spi_initMaster(DIP204_SPI, &SPI_OPTIONS);
	spi_selectionMode(DIP204_SPI, 0, 0, 0);
	spi_setupChipReg(DIP204_SPI, &SPI_OPTIONS, FOSC0);
	spi_enable(DIP204_SPI);
	dip204_init(backlight_PWM, true);
	
	//ADC init
	AVR32_ADC.mr |= 0x1 << AVR32_ADC_MR_PRESCAL_OFFSET;
	adc_configure(&AVR32_ADC);
	adc_enable(&AVR32_ADC, 1);
	
	//USART init
	usart_init_rs232(usart1, &USART_OPTIONS, FOSC0);
	
	//TWI init
	opt.pba_hz = FOSC0;
	opt.speed = TWI_SPEED;
	opt.chip = RTC_ADDRESS;
	twi_master_init(&AVR32_TWI, &opt);
	
	//Configure_joystick_IT();
	gpio_enable_pin_interrupt(GPIO_JOYSTICK_UP , GPIO_FALLING_EDGE);
	gpio_enable_pin_interrupt(GPIO_JOYSTICK_DOWN , GPIO_FALLING_EDGE);
	gpio_enable_pin_interrupt(GPIO_JOYSTICK_RIGHT , GPIO_FALLING_EDGE);
	gpio_enable_pin_interrupt(GPIO_JOYSTICK_PUSH , GPIO_FALLING_EDGE);
	gpio_enable_pin_interrupt(GPIO_JOYSTICK_LEFT , GPIO_FALLING_EDGE);

	Disable_global_interrupt();
	INTC_register_interrupt( &Joy_int_handler, AVR32_GPIO_IRQ_0 + (GPIO_JOYSTICK_UP/8), AVR32_INTC_INT1);
	INTC_register_interrupt( &Joy_int_handler, AVR32_GPIO_IRQ_0 + (GPIO_JOYSTICK_DOWN/8), AVR32_INTC_INT1);
	INTC_register_interrupt( &Joy_int_handler, AVR32_GPIO_IRQ_0 + (GPIO_JOYSTICK_RIGHT/8), AVR32_INTC_INT1);
	INTC_register_interrupt( &Joy_int_handler, AVR32_GPIO_IRQ_0 + (GPIO_JOYSTICK_LEFT/8), AVR32_INTC_INT1);
	INTC_register_interrupt( &Joy_int_handler, AVR32_GPIO_IRQ_0 + (GPIO_JOYSTICK_PUSH/8), AVR32_INTC_INT1);
	Enable_global_interrupt();
	
	//configure_push_buttons_IT();
	gpio_enable_pin_interrupt(PB0 , GPIO_RISING_EDGE);
	gpio_enable_pin_interrupt(PB1 , GPIO_RISING_EDGE);
	gpio_enable_pin_interrupt(PB2 , GPIO_RISING_EDGE);

	Disable_global_interrupt();
	INTC_register_interrupt( &PB_int_handler, AVR32_GPIO_IRQ_0 + (PB2/8), AVR32_INTC_INT1);
	INTC_register_interrupt( &PB_int_handler, AVR32_GPIO_IRQ_0 + (PB1/8), AVR32_INTC_INT1);
	INTC_register_interrupt( &PB_int_handler, AVR32_GPIO_IRQ_0 + (PB0/8), AVR32_INTC_INT1);
	Enable_global_interrupt();
}

int main(void){
	INIT();
	
	while (1){
		//USART_read_example();
		//Light_sensor();
		//Temperature_sensor();
		
		DH(0); //but why
		
		Joy_int_handler();
		PB_int_handler();
		Potmeter_control();
		dip204_clear_display();
		Read_RTC();
		
		switch(Button_cases){
			case 1:
			display_1(1,"B:");
			display_1(3,itoa(joy_button));
			display_1(6, "Schakelklok 1");
			display_3(1,set_time());
			break;
			
			case 2:
			display_1(1,display_time(1));
			display_2(1,display_time(2));
			display_3(1,display_time(3));
			display_4(1,display_time(4));
			break;
			
			case 3:
			display_1(6,"DS3231 RTS");
			display_2(1,"Time: --:--:--");
			display_3(1,"Date: - -- -- 20--");
			dip204_set_cursor_position(y,x);
			
			
			unsigned int place = 1;
			for(int i = 0; i < 7 ; i ++){
				display_4(place,itoa(bcd_to_decimal(tbuffer[i])));
				place = place + 3;
			}
			
			if(joy_button == 1){ Write_RTC(); }
			break;
		}
		
		set_time(); //problem?
		dip204_set_cursor_position(y,x);
		
		var_delay_ms(100);
	}
	return 0;
}

void display_1(int pos_1, char* string_1){
	dip204_set_cursor_position(pos_1,1);
	dip204_write_string(string_1);
}
void display_2(int pos_2, char* string_2){
	dip204_set_cursor_position(pos_2,2);
	dip204_write_string(string_2);
}
void display_3(int pos_3, char* string_3){
	dip204_set_cursor_position(pos_3,3);
	dip204_write_string(string_3);
}
void display_4(int pos_4, char* string_4){
	dip204_set_cursor_position(pos_4,4);
	dip204_write_string(string_4);
}
void Potmeter_control(void)
{
	adc_enable(&AVR32_ADC, ADC_POTENTIOMETER_CHANNEL);
	adc_start(&AVR32_ADC);
	adc_value_pot = adc_get_value(&AVR32_ADC, ADC_POTENTIOMETER_CHANNEL);
	adc_disable(&AVR32_ADC, ADC_POTENTIOMETER_CHANNEL);
}
int Potmeter_value(void)
{
	adc_enable(&AVR32_ADC, ADC_POTENTIOMETER_CHANNEL);
	adc_start(&AVR32_ADC);
	adc_value_pot = adc_get_value(&AVR32_ADC, ADC_POTENTIOMETER_CHANNEL);
	adc_disable(&AVR32_ADC, ADC_POTENTIOMETER_CHANNEL);
	
	return (adc_value_pot / 103 % 10);
}
static void Joy_int_handler(){
	if (gpio_get_pin_interrupt_flag(GPIO_JOYSTICK_UP)){
		var_delay_ms(1);
		x = x - 1;
		if (x < 1){
			x = 4;
		}
		gpio_clear_pin_interrupt_flag(GPIO_JOYSTICK_UP); // allow new interrupt : clear the IFR flag
	}
	if (gpio_get_pin_interrupt_flag(GPIO_JOYSTICK_DOWN)){
		x = x + 1;
		if (x > 4){
			x = 1;
		}
		gpio_clear_pin_interrupt_flag(GPIO_JOYSTICK_DOWN); // allow new interrupt : clear the IFR flag
	}
	if (gpio_get_pin_interrupt_flag(GPIO_JOYSTICK_LEFT)){
		y = y - 1;
		if (y < 1){
			y = 20;
		}
		gpio_clear_pin_interrupt_flag(GPIO_JOYSTICK_LEFT); // allow new interrupt : clear the IFR flag
	}
	if (gpio_get_pin_interrupt_flag(GPIO_JOYSTICK_RIGHT)){
		y = y + 1;
		if (y > 20){
			y = 1;
		}
		gpio_clear_pin_interrupt_flag(GPIO_JOYSTICK_RIGHT); // allow new interrupt : clear the IFR flag
	}
	
	if (gpio_get_pin_interrupt_flag(GPIO_JOYSTICK_PUSH)){ // change time when pushed
		joy_button = joy_button + 1;
		if (joy_button > 1){
			joy_button = 0;
		}
		gpio_clear_pin_interrupt_flag(GPIO_JOYSTICK_PUSH);  // allow new interrupt : clear the IFR flag
	}
	var_delay_ms(1);
}
static void PB_int_handler(){
	if (gpio_get_pin_interrupt_flag(PB0)){
		Button_cases = Button_cases + 1;
		if (Button_cases == 4){
			Button_cases = 1;
		}
		gpio_clear_pin_interrupt_flag(PB0);
	}

	if (gpio_get_pin_interrupt_flag(PB1)){
		Button_cases = 2;
		gpio_clear_pin_interrupt_flag(PB1);
	}

	if (gpio_get_pin_interrupt_flag(PB2)){
		Button_cases = 3;
		gpio_clear_pin_interrupt_flag(PB2);
	}
	var_delay_ms(1);
}
char* set_time(){
	char *result = malloc(20);
	
	int time_20 = time_uitgang[poort_number] % 60 % 10;
	int time_19 = time_uitgang[poort_number] % 60 / 10 % 10;
	int time_17 = (time_uitgang[poort_number] / 60) % 60 % 10;
	int time_16 = (time_uitgang[poort_number] / 60) % 60 / 10 % 10;
	int time_14 = (time_uitgang[poort_number] / 3600) % 60 % 10;
	int time_13 = (time_uitgang[poort_number] / 3600) % 60 / 10 % 10;
	int time_11 = (time_uitgang[poort_number] / 216000) % 24 % 10;
	int time_10 = (time_uitgang[poort_number] / 216000) % 24 / 10 % 10;
	
	if(joy_button == 1 && x == 3 && y > 9){
		if(y == 20){ time_20 = Potmeter_value(); }
		if(y == 19){
			if(Potmeter_value() > 5){ time_19 = 5; }
			else{ time_19 = Potmeter_value(); }
		}
		if(y == 17){ time_17 = Potmeter_value(); }
		if(y == 16){
			if(Potmeter_value() > 5){ time_16 = 5; }
			else{ time_16 = Potmeter_value(); }
		}
		if(y == 14){ time_14 = Potmeter_value(); }
		if(y == 13){
			if(Potmeter_value() > 5){ time_13 = 5; }
			else{ time_13 = Potmeter_value(); }
		}
		if(y == 11){
			if(Potmeter_value() > 3){ time_11 = 3; }
			else{ time_11 = Potmeter_value(); }
		}
		if(y == 10){
			if(Potmeter_value() > 2){ time_10 = 2; }
			else{ time_10 = Potmeter_value(); }
		}
		
		time_uitgang[poort_number] = (time_10 * 10 + time_11) * 60 * 60 * 60 + (time_13 * 10 + time_14) * 60 * 60 + (time_16 * 10 + time_17) * 60 + (time_19 * 10 + time_20);
	}
	
	if(Button_cases != 3){
		poort_number = (Potmeter_value()/3%4 + 1);
	}
	else{
		poort_number = 0;
	}
	
	strcpy(result, "Poort ");
	strcat(result, itoa(poort_number));
	strcat(result, ": ");
	strcat(result, itoa(time_10));
	strcat(result, itoa(time_11));
	strcat(result, ":");
	strcat(result, itoa(time_13));
	strcat(result, itoa(time_14));
	strcat(result, ":");
	strcat(result, itoa(time_16));
	strcat(result, itoa(time_17));
	strcat(result, ":");
	strcat(result, itoa(time_19));
	strcat(result, itoa(time_20));
	
	return result;
}

char* display_time(int poortnumber){
	
	char *result = malloc(20);
	
	strcpy(result, "Poort ");
	strcat(result, itoa(poortnumber));
	strcat(result, ": ");
	strcat(result, itoa((time_uitgang[poortnumber] / 216000) % 24 / 10 % 10));
	strcat(result, itoa((time_uitgang[poortnumber] / 216000) % 24 % 10));
	strcat(result, ":");
	strcat(result, itoa((time_uitgang[poortnumber] / 3600) % 60 / 10 % 10));
	strcat(result, itoa((time_uitgang[poortnumber] / 3600) % 60 % 10));
	strcat(result, ":");
	strcat(result, itoa((time_uitgang[poortnumber] / 60) % 60 / 10 % 10));
	strcat(result, itoa((time_uitgang[poortnumber] / 60) % 60 % 10));
	strcat(result, ":");
	strcat(result, itoa(time_uitgang[poortnumber] % 60 / 10 % 10));
	strcat(result, itoa(time_uitgang[poortnumber] % 60 % 10));
	
	return result;
}
void Light_sensor(void)
{
	adc_enable(&AVR32_ADC, ADC_LIGHT_CHANNEL);
	adc_start(&AVR32_ADC);
	adc_value_light = adc_get_value(&AVR32_ADC, ADC_LIGHT_CHANNEL);
	
	if (adc_value_light > 512){LED_On(0x02);}
	else{LED_Off(0x02);}
	adc_disable(&AVR32_ADC, ADC_LIGHT_CHANNEL);
}
void Temperature_sensor(void)
{
	adc_enable(&AVR32_ADC, ADC_TEMPERATURE_CHANNEL);
	adc_start(&AVR32_ADC);
	adc_value_temp = adc_get_value(&AVR32_ADC, ADC_TEMPERATURE_CHANNEL);
	if (adc_value_temp > 512){LED_On(0x04);}
	else{LED_Off(0x04);}
	adc_disable(&AVR32_ADC, ADC_TEMPERATURE_CHANNEL);
}

void Read_RTC(void){
	packet_received.chip = 0b01101000;
	packet_received.addr_length = sizeof (uint8_t);
	packet_received.length = 16;
	packet_received.addr[0] = 0x00;
	packet_received.buffer = &tbuffer;
	twi_master_read(&AVR32_TWI, &packet_received);
}
void Write_RTC(void){
	packet_received.chip = 0b01101000;
	packet_received.addr_length = sizeof (uint8_t);
	packet_received.length = 7;
	packet_received.addr[0] = 0x00;
	packet_received.buffer = &tbuffer;
	twi_master_read(&AVR32_TWI, &packet_received);
	
	display_2(9," ");
	display_2(12," ");
	
	int time_h = (bcd_to_decimal(tbuffer[2])) / 10 % 10;
	int time_hh = (bcd_to_decimal(tbuffer[2])) % 10;
	int time_m = (bcd_to_decimal(tbuffer[1])) / 10 % 10;
	int time_mm = (bcd_to_decimal(tbuffer[1])) % 10;
	int time_s = (bcd_to_decimal(tbuffer[0])) / 10 % 10;
	int time_ss = (bcd_to_decimal(tbuffer[0])) % 10;
	
	int time_day = bcd_to_decimal(tbuffer[3]);
	int time_d = (bcd_to_decimal(tbuffer[4])) / 10 % 10;
	int time_dd = (bcd_to_decimal(tbuffer[4])) % 10;
	int time_month = (bcd_to_decimal(tbuffer[5])) / 10 % 10;
	int time_month_month = (bcd_to_decimal(tbuffer[5])) % 10;
	int time_y = (bcd_to_decimal(tbuffer[6])) / 10 % 10;
	int time_yy = (bcd_to_decimal(tbuffer[6])) % 10;
	
	if(joy_button == 1 && x == 2){
		switch(y){
			case 7:
			if(Potmeter_value() > 2){ time_h = 2; }
			else{ time_h = Potmeter_value(); }
			break;
			
			case 8:
			if(Potmeter_value() > 3){ time_hh = 3; }
			else{ time_hh = Potmeter_value(); }
			break;
			
			case 10:
			if(Potmeter_value() > 5){ time_m = 5; }
			else{ time_m = Potmeter_value(); }
			break;
			
			case 11:
			time_mm = Potmeter_value();
			break;
			
			case 13:
			if(Potmeter_value() > 5){ time_s = 5; }
			else{ time_s = Potmeter_value(); }
			break;
			
			case 14:
			time_ss = Potmeter_value();
			break;
		}
		tbuffer[2] = decimal_to_bcd(time_h * 10 + time_hh);
		tbuffer[1] = decimal_to_bcd(time_m * 10 + time_mm);
		tbuffer[0] = decimal_to_bcd(time_s * 10 + time_ss);
	}
	
	if(joy_button == 1 && x == 3){
		switch(y){
			case 7:
			if(Potmeter_value() > 7){ time_day = 7; }
			else if(Potmeter_value() == 0){ time_day = 1; }
			else{ time_day = Potmeter_value(); }
			break;
			
			case 9:
			if(Potmeter_value() == 0 && time_dd == 0){ time_dd = 1;}
			if(Potmeter_value() > 3){ time_d = 3; if(time_dd > 1 ){time_dd = 1;} }
			else{ time_d = Potmeter_value(); }
			break;
			
			case 10:
			if (Potmeter_value() == 0 && time_d == 0){time_dd = 1;}
			else if(time_d == 3 && Potmeter_value() > 1){ time_dd = 1; }
			else if(time_d == 3 && Potmeter_value() == 0){ time_dd = 0; }
			else{ time_dd = Potmeter_value(); }
			break;
			
			case 12:
			if(Potmeter_value() == 0 && time_month_month == 0) { time_month_month = 1;}
			else if(Potmeter_value() > 1){ time_month = 1; if(time_month_month > 2 ){time_month_month = 2;} }
			else{ time_month = Potmeter_value(); }
			break;
			
			case 13:
			if(time_month == 0 && Potmeter_value() == 0){time_month_month = 1;}
			else if(time_month == 1 && Potmeter_value() > 2){ time_month_month = 2; }
			else if(time_month == 1){ time_month_month = Potmeter_value(); }
			else{ time_month_month = Potmeter_value(); }
			break;
			
			case 17:
			time_y = Potmeter_value();
			break;
			
			case 18:
			time_yy = Potmeter_value();
			break;
		}
		tbuffer[3] = decimal_to_bcd(time_day);
		tbuffer[4] = decimal_to_bcd(time_d * 10 + time_dd);
		tbuffer[5] = decimal_to_bcd(time_month * 10 + time_month_month);
		tbuffer[6] = decimal_to_bcd(time_y * 10 + time_yy);
		
	}
	
	packet_send.chip = 0b01101000;
	packet_send.addr_length = sizeof (uint8_t);
	packet_send.length = 16;
	packet_send.addr[0] = 0x00;
	packet_send.buffer = &tbuffer;
	twi_master_write(&AVR32_TWI, &packet_send);
}
